System Overview
===============

---------------------------------------
Object Lifecycles and responsibilities
---------------------------------------


Objects persisting across the entire scan run
---------------------------------------------

A "scan" consists of scanning a number of flows (it could be
thousands of flows) as determined by the CLI. Two objects
are instantiated at the start of a scan and
persist across the entire scan run:

* The :class:`flowtest.flow_result.Results.Processor` instances store results
  found during the scan run, perform basic de-duplication of results,
  and transform the internal result data structure to other data
  structures more appropriate for output serialization.

* The :class:`flowtest.query_manager.QueryManager` instances load queries as
  configured by the user, invoke the queries during flow execution, and store
  results in the results processor.

The query manager contains references to the results processor and is the main
object persisted across an entire scan run.

Objects persisting across the scan of a flow
--------------------------------------------

The scan of an individual flow consists of scanning the flow and all subflows
referenced by it. Tracking which flow is being scanned and wiring
the results of subflows to parent flows are handled in the :mod:`flowtest.executor`
module which contains two important classes, :class:`flowtest.executor.Stack` and
:class:`flowtest.executor.Frame`

QueryProcessor
~~~~~~~~~~~~~~

The :class:`public.contract.QueryProcessor` executes queries. It is The query processor is instantiated
by the QueryManager with each new flow parsed.


Stack
~~~~~
:class:`flowtest.executor.Stack` manages the list of frames, pushing and popping as new
subflows are entered and returned from.

Frame
~~~~~
:class:`flowtest.executor.Frame` handles symbolic execution of a single
flow file, instantiating the :class:`flow_parse.parse.Parser`, :class:`flowtest.branch_state.BranchState`
and :class:`flowtest.control_flow.Crawler`.


Objects Persisting across a single file
---------------------------------------
The parser, crawler, and branch state persist across a single flow file parse,
and are responsible for the heart of dataflow analysis.

Parser
~~~~~~
:class:`flow_parse.parse.Parser` parses the flow xml file and exposes all
lexical flow globals to the rest of the system. It must be instantiated first.

Other modules should pull lexical flow globals from the parser, rather than
trying to parse the flow xml file themselves.

The parser also owns the cache of variable type resolutions, :class:`flow_parse.parse.VariableType`
These are purely xml parsings of named elements,
containing static type information (and thus are
incomplete). These are stored in Variable type.


* The parser maintains two caches:

  - self.__parsed_vars:
    stores information about variable types,
    to avoid needing to constantly do xml parsing
    on variable definitions.

    There is no issue with cache consistency
    Because parsers are torn down when entering
    subflows and pointers to the parser
    for flow is stored by each frame so that the
    parser and full cache are recovered on re-entry.

  - self.__resolutions: Stores resolutions, so we don't always need to
    split Account.Name into "Account" and "Name"
    Here, too, there is no issue with cache inconsistency
    across a flow.


BranchState
~~~~~~~~~~~
:class:`flowtest.branch_state.BranchState` tracks the dataflows associated to each
flow global variable. It exposes an API to propagate flows by assignments
as well as to search whether a variable is influenced by another variable at any
execution step.

Other modules should always query :class:`flowtest.branch_state.BranchState` if they
have a dataflow question or want to modify a dataflow in the current
execution step.

Crawler
~~~~~~~

The crawler crawls a control flow graph (also generated by the :mod:`flowtest.control_flow`
module), producing a sequence of :class:`flowtest.control_flow.CrawlStep` entries
that are passed to :obj:`flowtest.branch_state.BranchState`.


QueryProcessor is initialized with a parser instance, stores a parser instance and a query instance

The query instance is also initialized with a parser.


Important Data types and caches
--------------------------------

When we speak of a (global) variable, it can exist in multiple states:

* completely new -- have never seen this variable.
* parsed - it has a parse definition in the parser, and
           therefore it has a variable type and can be used
           in flow definitions, as it's possible to resolve it.
* Initialized - it is in the influence map of a given-state

These three are stricter. E.g. every initialized variable is already parsed.


Ideally, *all* parseable variables are processed at
:meth:`flow_parser.parse.Parser.update` This is done via the get_all_named (which stores the elements)
and get_all_names (e.g. all_names) which stores the names of the elements.

So, in normal usage, every variable encountered by the flow should
already have a full name resolution in the parser cache.

But, it may not exist in the flow map. This is the question
of auto-initialization, which must be handled consistently in the code.

A variable may be initialized in one of two ways:
 - it appears as the influenced element in an assignment
   (auto-initialization should always happen for the influence target)
 - it is auto-initialized by the parser at flow parse (e.g. input variables)
 - it is lazily auto-initialized (all $-globals do this, but this is
        technically incorrect and should be revisited)


Important methods
------------------

__main__ (CLI) <-- Processes user input, to search
                   file system for flows to scan and repeatedly
                   calls results = executor.parse_flow(results, Job Info)

parse_flow() <-- main entry point, creates results object
                 and obtains list of all paths and specifies




